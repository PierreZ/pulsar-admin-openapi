/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * The version of the OpenAPI document: v2
 * 
 * Generated by: https://openapi-generator.tech
 */



#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Policies {
    #[serde(rename = "auth_policies", skip_serializing_if = "Option::is_none")]
    pub auth_policies: Option<crate::models::AuthPolicies>,
    #[serde(rename = "replication_clusters", skip_serializing_if = "Option::is_none")]
    pub replication_clusters: Option<Vec<String>>,
    #[serde(rename = "bundles", skip_serializing_if = "Option::is_none")]
    pub bundles: Option<crate::models::BundlesData>,
    #[serde(rename = "backlog_quota_map", skip_serializing_if = "Option::is_none")]
    pub backlog_quota_map: Option<::std::collections::HashMap<String, crate::models::BacklogQuota>>,
    #[serde(rename = "topicDispatchRate", skip_serializing_if = "Option::is_none")]
    pub topic_dispatch_rate: Option<::std::collections::HashMap<String, crate::models::DispatchRate>>,
    #[serde(rename = "subscriptionDispatchRate", skip_serializing_if = "Option::is_none")]
    pub subscription_dispatch_rate: Option<::std::collections::HashMap<String, crate::models::DispatchRate>>,
    #[serde(rename = "replicatorDispatchRate", skip_serializing_if = "Option::is_none")]
    pub replicator_dispatch_rate: Option<::std::collections::HashMap<String, crate::models::DispatchRate>>,
    #[serde(rename = "clusterSubscribeRate", skip_serializing_if = "Option::is_none")]
    pub cluster_subscribe_rate: Option<::std::collections::HashMap<String, crate::models::SubscribeRate>>,
    #[serde(rename = "persistence", skip_serializing_if = "Option::is_none")]
    pub persistence: Option<crate::models::PersistencePolicies>,
    #[serde(rename = "deduplicationEnabled", skip_serializing_if = "Option::is_none")]
    pub deduplication_enabled: Option<bool>,
    #[serde(rename = "latency_stats_sample_rate", skip_serializing_if = "Option::is_none")]
    pub latency_stats_sample_rate: Option<::std::collections::HashMap<String, i32>>,
    #[serde(rename = "message_ttl_in_seconds", skip_serializing_if = "Option::is_none")]
    pub message_ttl_in_seconds: Option<i32>,
    #[serde(rename = "retention_policies", skip_serializing_if = "Option::is_none")]
    pub retention_policies: Option<crate::models::RetentionPolicies>,
    #[serde(rename = "deleted", skip_serializing_if = "Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(rename = "antiAffinityGroup", skip_serializing_if = "Option::is_none")]
    pub anti_affinity_group: Option<String>,
    #[serde(rename = "encryption_required", skip_serializing_if = "Option::is_none")]
    pub encryption_required: Option<bool>,
    #[serde(rename = "subscription_auth_mode", skip_serializing_if = "Option::is_none")]
    pub subscription_auth_mode: Option<SubscriptionAuthMode>,
    #[serde(rename = "max_producers_per_topic", skip_serializing_if = "Option::is_none")]
    pub max_producers_per_topic: Option<i32>,
    #[serde(rename = "max_consumers_per_topic", skip_serializing_if = "Option::is_none")]
    pub max_consumers_per_topic: Option<i32>,
    #[serde(rename = "max_consumers_per_subscription", skip_serializing_if = "Option::is_none")]
    pub max_consumers_per_subscription: Option<i32>,
    #[serde(rename = "compaction_threshold", skip_serializing_if = "Option::is_none")]
    pub compaction_threshold: Option<i64>,
    #[serde(rename = "offload_threshold", skip_serializing_if = "Option::is_none")]
    pub offload_threshold: Option<i64>,
    #[serde(rename = "offload_deletion_lag_ms", skip_serializing_if = "Option::is_none")]
    pub offload_deletion_lag_ms: Option<i64>,
    #[serde(rename = "schema_auto_update_compatibility_strategy", skip_serializing_if = "Option::is_none")]
    pub schema_auto_update_compatibility_strategy: Option<SchemaAutoUpdateCompatibilityStrategy>,
    #[serde(rename = "schema_validation_enforced", skip_serializing_if = "Option::is_none")]
    pub schema_validation_enforced: Option<bool>,
}

impl Policies {
    pub fn new() -> Policies {
        Policies {
            auth_policies: None,
            replication_clusters: None,
            bundles: None,
            backlog_quota_map: None,
            topic_dispatch_rate: None,
            subscription_dispatch_rate: None,
            replicator_dispatch_rate: None,
            cluster_subscribe_rate: None,
            persistence: None,
            deduplication_enabled: None,
            latency_stats_sample_rate: None,
            message_ttl_in_seconds: None,
            retention_policies: None,
            deleted: None,
            anti_affinity_group: None,
            encryption_required: None,
            subscription_auth_mode: None,
            max_producers_per_topic: None,
            max_consumers_per_topic: None,
            max_consumers_per_subscription: None,
            compaction_threshold: None,
            offload_threshold: None,
            offload_deletion_lag_ms: None,
            schema_auto_update_compatibility_strategy: None,
            schema_validation_enforced: None,
        }
    }
}

/// 
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SubscriptionAuthMode {
    #[serde(rename = "None")]
    None,
    #[serde(rename = "Prefix")]
    Prefix,
}
/// 
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SchemaAutoUpdateCompatibilityStrategy {
    #[serde(rename = "AutoUpdateDisabled")]
    AutoUpdateDisabled,
    #[serde(rename = "Backward")]
    Backward,
    #[serde(rename = "Forward")]
    Forward,
    #[serde(rename = "Full")]
    Full,
    #[serde(rename = "AlwaysCompatible")]
    AlwaysCompatible,
    #[serde(rename = "BackwardTransitive")]
    BackwardTransitive,
    #[serde(rename = "ForwardTransitive")]
    ForwardTransitive,
    #[serde(rename = "FullTransitive")]
    FullTransitive,
}

