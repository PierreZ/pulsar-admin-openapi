/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * The version of the OpenAPI document: v2
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct NamespacesApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> NamespacesApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> NamespacesApiClient<C> {
        NamespacesApiClient {
            configuration: configuration,
        }
    }
}

pub trait NamespacesApi {
    fn clear_namespace_backlog(&self, tenant: &str, namespace: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn clear_namespace_backlog_for_subscription(&self, tenant: &str, namespace: &str, subscription: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn clear_namespace_bundle_backlog(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn clear_namespace_bundle_backlog_for_subscription(&self, tenant: &str, namespace: &str, subscription: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn clear_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn create_namespace(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_bookie_affinity_group(&self, property: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_namespace(&self, tenant: &str, namespace: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_anti_affinity_namespaces(&self, cluster: &str, group: &str, tenant: &str) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>>;
    fn get_backlog_quota_map(&self, tenant: &str, namespace: &str) -> Box<Future<Item = ::std::collections::HashMap<String, serde_json::Value>, Error = Error<serde_json::Value>>>;
    fn get_bookie_affinity_group(&self, property: &str, namespace: &str) -> Box<Future<Item = crate::models::BookieAffinityGroupData, Error = Error<serde_json::Value>>>;
    fn get_bundles_data(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::BundlesData, Error = Error<serde_json::Value>>>;
    fn get_compaction_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>>;
    fn get_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>>;
    fn get_max_consumers_per_subscription(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn get_max_consumers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn get_max_producers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn get_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn get_namespace_message_ttl(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>>;
    fn get_namespace_replication_clusters(&self, tenant: &str, namespace: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn get_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>>;
    fn get_offload_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>>;
    fn get_permissions(&self, tenant: &str, cluster: &str, namespace: &str) -> Box<Future<Item = ::std::collections::HashMap<String, serde_json::Value>, Error = Error<serde_json::Value>>>;
    fn get_persistence(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::PersistencePolicies, Error = Error<serde_json::Value>>>;
    fn get_policies(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::Policies, Error = Error<serde_json::Value>>>;
    fn get_replicator_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>>;
    fn get_retention(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::RetentionPolicies, Error = Error<serde_json::Value>>>;
    fn get_schema_auto_update_compatibility_strategy(&self, tenant: &str, namespace: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>>;
    fn get_schema_validtion_enforced(&self, tenant: &str, namespace: &str) -> Box<Future<Item = bool, Error = Error<serde_json::Value>>>;
    fn get_subscribe_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::SubscribeRate, Error = Error<serde_json::Value>>>;
    fn get_subscription_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>>;
    fn get_tenant_namespaces(&self, tenant: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn get_topics(&self, tenant: &str, namespace: &str, mode: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>>;
    fn grant_permission_on_namespace(&self, tenant: &str, namespace: &str, role: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn modify_deduplication(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn modify_encryption_required(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn remove_backlog_quota(&self, tenant: &str, namespace: &str, backlog_quota_type: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn remove_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn revoke_permissions_on_namespace(&self, tenant: &str, namespace: &str, role: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_backlog_quota(&self, tenant: &str, namespace: &str, backlog_quota_type: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_bookie_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_compaction_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_max_consumers_per_subscription(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_max_consumers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_max_producers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_namespace_message_ttl(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_namespace_replication_clusters(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_offload_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_persistence(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_replicator_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_retention(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_schema_auto_update_compatibility_strategy(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_schema_validtion_enforced(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_subscribe_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_subscription_auth_mode(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn set_subscription_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn split_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool, unload: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn unload_namespace(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn unload_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn unsubscribe_namespace(&self, tenant: &str, cluster: &str, namespace: &str, subscription: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn unsubscribe_namespace_bundle(&self, tenant: &str, namespace: &str, subscription: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>NamespacesApi for NamespacesApiClient<C> {
    fn clear_namespace_backlog(&self, tenant: &str, namespace: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/clearBacklog".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn clear_namespace_backlog_for_subscription(&self, tenant: &str, namespace: &str, subscription: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/clearBacklog/{subscription}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("subscription".to_string(), subscription.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn clear_namespace_bundle_backlog(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn clear_namespace_bundle_backlog_for_subscription(&self, tenant: &str, namespace: &str, subscription: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog/{subscription}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("subscription".to_string(), subscription.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn clear_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn create_namespace(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn delete_bookie_affinity_group(&self, property: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{property}/{namespace}/persistence/bookieAffinity".to_string())
            .with_path_param("property".to_string(), property.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn delete_namespace(&self, tenant: &str, namespace: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn delete_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}/{bundle}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn get_anti_affinity_namespaces(&self, cluster: &str, group: &str, tenant: &str) -> Box<Future<Item = Vec<serde_json::Value>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{cluster}/antiAffinity/{group}".to_string())
            .with_query_param("tenant".to_string(), tenant.to_string())
            .with_path_param("cluster".to_string(), cluster.to_string())
            .with_path_param("group".to_string(), group.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_backlog_quota_map(&self, tenant: &str, namespace: &str) -> Box<Future<Item = ::std::collections::HashMap<String, serde_json::Value>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/backlogQuotaMap".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_bookie_affinity_group(&self, property: &str, namespace: &str) -> Box<Future<Item = crate::models::BookieAffinityGroupData, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{property}/{namespace}/persistence/bookieAffinity".to_string())
            .with_path_param("property".to_string(), property.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_bundles_data(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::BundlesData, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/bundles".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_compaction_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/compactionThreshold".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/dispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_max_consumers_per_subscription(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_max_consumers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_max_producers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/maxProducersPerTopic".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/antiAffinity".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_namespace_message_ttl(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i32, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/messageTTL".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_namespace_replication_clusters(&self, tenant: &str, namespace: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/replication".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_offload_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = i64, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/offloadThreshold".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_permissions(&self, tenant: &str, cluster: &str, namespace: &str) -> Box<Future<Item = ::std::collections::HashMap<String, serde_json::Value>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/permissions".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("cluster".to_string(), cluster.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_persistence(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::PersistencePolicies, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/persistence".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_policies(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::Policies, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_replicator_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/replicatorDispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_retention(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::RetentionPolicies, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/retention".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_schema_auto_update_compatibility_strategy(&self, tenant: &str, namespace: &str) -> Box<Future<Item = String, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_schema_validtion_enforced(&self, tenant: &str, namespace: &str) -> Box<Future<Item = bool, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/schemaValidationEnforced".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_subscribe_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::SubscribeRate, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/subscribeRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_subscription_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = crate::models::DispatchRate, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_tenant_namespaces(&self, tenant: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .execute(self.configuration.borrow())
    }

    fn get_topics(&self, tenant: &str, namespace: &str, mode: &str) -> Box<Future<Item = Vec<String>, Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Get, "/namespaces/{tenant}/{namespace}/topics".to_string())
            .with_query_param("mode".to_string(), mode.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .execute(self.configuration.borrow())
    }

    fn grant_permission_on_namespace(&self, tenant: &str, namespace: &str, role: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/permissions/{role}".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("role".to_string(), role.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn modify_deduplication(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/deduplication".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn modify_encryption_required(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/encryptionRequired".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn remove_backlog_quota(&self, tenant: &str, namespace: &str, backlog_quota_type: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}/backlogQuota".to_string())
            .with_query_param("backlogQuotaType".to_string(), backlog_quota_type.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn remove_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}/antiAffinity".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn revoke_permissions_on_namespace(&self, tenant: &str, namespace: &str, role: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Delete, "/namespaces/{tenant}/{namespace}/permissions/{role}".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("role".to_string(), role.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_backlog_quota(&self, tenant: &str, namespace: &str, backlog_quota_type: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/backlogQuota".to_string())
            .with_query_param("backlogQuotaType".to_string(), backlog_quota_type.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_bookie_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/persistence/bookieAffinity".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_compaction_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/compactionThreshold".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/dispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_max_consumers_per_subscription(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_max_consumers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_max_producers_per_topic(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/maxProducersPerTopic".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_namespace_anti_affinity_group(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/antiAffinity".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_namespace_message_ttl(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/messageTTL".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_namespace_replication_clusters(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/replication".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_offload_deletion_lag(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_offload_threshold(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/offloadThreshold".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_persistence(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/persistence".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_replicator_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/replicatorDispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_retention(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/retention".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_schema_auto_update_compatibility_strategy(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_schema_validtion_enforced(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/schemaValidationEnforced".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_subscribe_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/subscribeRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_subscription_auth_mode(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/subscriptionAuthMode".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn set_subscription_dispatch_rate(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn split_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool, unload: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/{bundle}/split".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_query_param("unload".to_string(), unload.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn unload_namespace(&self, tenant: &str, namespace: &str) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/unload".to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn unload_namespace_bundle(&self, tenant: &str, namespace: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Put, "/namespaces/{tenant}/{namespace}/{bundle}/unload".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn unsubscribe_namespace(&self, tenant: &str, cluster: &str, namespace: &str, subscription: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/unsubscribe/{subscription}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("cluster".to_string(), cluster.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("subscription".to_string(), subscription.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

    fn unsubscribe_namespace_bundle(&self, tenant: &str, namespace: &str, subscription: &str, bundle: &str, authoritative: bool) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        __internal_request::Request::new(hyper::Method::Post, "/namespaces/{tenant}/{namespace}/{bundle}/unsubscribe/{subscription}".to_string())
            .with_query_param("authoritative".to_string(), authoritative.to_string())
            .with_path_param("tenant".to_string(), tenant.to_string())
            .with_path_param("namespace".to_string(), namespace.to_string())
            .with_path_param("subscription".to_string(), subscription.to_string())
            .with_path_param("bundle".to_string(), bundle.to_string())
            .returns_nothing()
            .execute(self.configuration.borrow())
    }

}
